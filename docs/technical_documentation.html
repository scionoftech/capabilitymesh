<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CapabilityMesh - Technical Documentation</title>
    <style>
        :root {
            --primary-color: #2980b9;
            --primary-hover: #3498db;
            --bg-color: #fcfcfc;
            --sidebar-bg: #343131;
            --sidebar-text: #d9d9d9;
            --sidebar-hover: #4e4a4a;
            --code-bg: #f5f7f9;
            --border-color: #e1e4e8;
            --text-color: #404040;
            --heading-color: #2c3e50;
            --link-color: #2980b9;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --info-color: #3498db;
        }

        [data-theme="dark"] {
            --bg-color: #1e1e1e;
            --sidebar-bg: #252526;
            --sidebar-text: #cccccc;
            --sidebar-hover: #37373d;
            --code-bg: #2d2d30;
            --border-color: #3e3e42;
            --text-color: #d4d4d4;
            --heading-color: #e0e0e0;
            --link-color: #4fc3f7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.7;
            color: var(--text-color);
            background: var(--bg-color);
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--sidebar-bg);
            color: var(--sidebar-text);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        .sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: var(--sidebar-bg);
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--sidebar-hover);
            border-radius: 4px;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--sidebar-hover);
            position: sticky;
            top: 0;
            background: var(--sidebar-bg);
            z-index: 10;
        }

        .sidebar-header h1 {
            font-size: 22px;
            color: white;
            margin-bottom: 5px;
        }

        .sidebar-header .version {
            font-size: 12px;
            color: var(--success-color);
            font-weight: 600;
        }

        .theme-toggle {
            margin-top: 15px;
            padding: 8px 12px;
            background: var(--sidebar-hover);
            border: none;
            border-radius: 4px;
            color: var(--sidebar-text);
            cursor: pointer;
            font-size: 12px;
            width: 100%;
            transition: background 0.2s;
        }

        .theme-toggle:hover {
            background: var(--primary-color);
        }

        .sidebar-nav {
            padding: 10px 0;
        }

        .nav-section {
            margin-bottom: 5px;
        }

        .nav-section-title {
            padding: 12px 20px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #999;
            font-weight: 600;
        }

        .nav-link {
            display: block;
            padding: 10px 20px 10px 40px;
            color: var(--sidebar-text);
            text-decoration: none;
            font-size: 14px;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .nav-link:hover {
            background: var(--sidebar-hover);
            color: white;
            border-left-color: var(--primary-color);
        }

        .nav-link.active {
            background: var(--sidebar-hover);
            color: white;
            border-left-color: var(--primary-color);
        }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            flex: 1;
            padding: 40px 60px;
            max-width: 1200px;
        }

        .content-header {
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .content-header h1 {
            font-size: 36px;
            color: var(--heading-color);
            margin-bottom: 10px;
        }

        .content-header .subtitle {
            font-size: 18px;
            color: #7f8c8d;
        }

        .section {
            margin-bottom: 50px;
            scroll-margin-top: 20px;
        }

        h2 {
            font-size: 28px;
            color: var(--heading-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        h3 {
            font-size: 22px;
            color: var(--heading-color);
            margin: 30px 0 15px 0;
        }

        h4 {
            font-size: 18px;
            color: var(--heading-color);
            margin: 25px 0 12px 0;
        }

        p {
            margin-bottom: 15px;
        }

        code {
            background: var(--code-bg);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e74c3c;
        }

        pre {
            background: var(--code-bg);
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        pre code {
            background: none;
            padding: 0;
            color: var(--text-color);
            font-size: 14px;
            line-height: 1.5;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .badge-primary {
            background: #3498db;
            color: white;
        }

        .badge-success {
            background: #27ae60;
            color: white;
        }

        .badge-warning {
            background: #f39c12;
            color: white;
        }

        .badge-info {
            background: #16a085;
            color: white;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 6px;
            margin: 20px 0;
            border-left: 4px solid;
        }

        .alert-info {
            background: #e8f4f8;
            border-left-color: #3498db;
            color: #2c3e50;
        }

        .alert-success {
            background: #e8f5e9;
            border-left-color: #27ae60;
            color: #2c3e50;
        }

        .alert-warning {
            background: #fff3cd;
            border-left-color: #f39c12;
            color: #856404;
        }

        [data-theme="dark"] .alert-info {
            background: #1a2933;
            color: #4fc3f7;
        }

        [data-theme="dark"] .alert-success {
            background: #1b2e1f;
            color: #66bb6a;
        }

        [data-theme="dark"] .alert-warning {
            background: #332a1a;
            color: #ffb74d;
        }

        .api-method {
            background: var(--code-bg);
            padding: 20px;
            border-radius: 6px;
            margin: 20px 0;
            border-left: 4px solid var(--primary-color);
        }

        .api-method h4 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .api-signature {
            background: rgba(41, 128, 185, 0.1);
            padding: 10px 15px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            overflow-x: auto;
        }

        .param-list {
            margin: 15px 0;
        }

        .param-item {
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .param-item:last-child {
            border-bottom: none;
        }

        .param-name {
            font-weight: 600;
            color: var(--primary-color);
            font-family: monospace;
        }

        .param-type {
            color: #7f8c8d;
            font-style: italic;
            font-size: 0.9em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        th {
            background: var(--code-bg);
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            color: var(--heading-color);
            border-bottom: 2px solid var(--border-color);
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:hover {
            background: var(--code-bg);
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin-bottom: 8px;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .feature-card {
            background: var(--code-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .feature-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .feature-card h4 {
            margin-top: 0;
            color: var(--primary-color);
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }

            .main-content {
                margin-left: 0;
                padding: 20px;
            }

            .feature-grid {
                grid-template-columns: 1fr;
            }
        }

        .search-box {
            padding: 15px 20px;
            border-bottom: 1px solid var(--sidebar-hover);
        }

        .search-input {
            width: 100%;
            padding: 10px;
            background: var(--sidebar-hover);
            border: none;
            border-radius: 4px;
            color: var(--sidebar-text);
            font-size: 14px;
        }

        .search-input::placeholder {
            color: #999;
        }

        .search-input:focus {
            outline: 2px solid var(--primary-color);
        }

        .toc {
            background: var(--code-bg);
            padding: 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            margin: 20px 0;
        }

        .toc h3 {
            margin-top: 0;
            font-size: 18px;
        }

        .toc ul {
            margin-left: 20px;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--primary-color);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: all 0.3s;
            font-size: 24px;
        }

        .back-to-top:hover {
            background: var(--primary-hover);
            transform: translateY(-5px);
        }

        .back-to-top.show {
            display: flex;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar Navigation -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>CapabilityMesh</h1>
                <div class="version">v1.0.0-alpha.1</div>
                <button class="theme-toggle" onclick="toggleTheme()">üåì Toggle Theme</button>
            </div>

            <div class="search-box">
                <input type="text" class="search-input" placeholder="Search documentation..." id="searchInput">
            </div>

            <nav class="sidebar-nav">
                <div class="nav-section">
                    <div class="nav-section-title">Getting Started</div>
                    <a href="#introduction" class="nav-link">Introduction</a>
                    <a href="#installation" class="nav-link">Installation</a>
                    <a href="#quick-start" class="nav-link">Quick Start</a>
                    <a href="#key-concepts" class="nav-link">Key Concepts</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Core API</div>
                    <a href="#mesh-api" class="nav-link">Mesh</a>
                    <a href="#agent-info" class="nav-link">AgentInfo</a>
                    <a href="#capability-api" class="nav-link">Capability</a>
                    <a href="#identity-api" class="nav-link">Identity & Address</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Storage</div>
                    <a href="#storage-overview" class="nav-link">Overview</a>
                    <a href="#inmemory-storage" class="nav-link">InMemory</a>
                    <a href="#sqlite-storage" class="nav-link">SQLite</a>
                    <a href="#redis-storage" class="nav-link">Redis</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Trust & Security</div>
                    <a href="#trust-system" class="nav-link">Trust Management</a>
                    <a href="#trust-levels" class="nav-link">Trust Levels</a>
                    <a href="#trust-api" class="nav-link">Trust API</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Advanced</div>
                    <a href="#embeddings" class="nav-link">Embeddings</a>
                    <a href="#framework-integration" class="nav-link">Framework Integration</a>
                    <a href="#multi-agent-workflows" class="nav-link">Multi-Agent Workflows</a>
                    <a href="#best-practices" class="nav-link">Best Practices</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Examples</div>
                    <a href="#example-basic" class="nav-link">Basic Usage</a>
                    <a href="#example-storage" class="nav-link">Storage Backends</a>
                    <a href="#example-trust" class="nav-link">Trust Management</a>
                    <a href="#example-semantic" class="nav-link">Semantic Search</a>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">Resources</div>
                    <a href="https://github.com/scionoftech/capabilitymesh/blob/main/DISCOVERY_ARCHITECTURE.md" target="_blank" class="nav-link">Discovery Architecture ‚Üó</a>
                    <a href="#troubleshooting" class="nav-link">Troubleshooting</a>
                    <a href="#faq" class="nav-link">FAQ</a>
                    <a href="#changelog" class="nav-link">Changelog</a>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content-header">
                <h1>CapabilityMesh Technical Documentation</h1>
                <p class="subtitle">Universal capability discovery and negotiation for multi-agent systems</p>
                <div style="margin-top: 15px;">
                    <span class="badge badge-primary">v1.0.0-alpha.1</span>
                    <span class="badge badge-success">137 Tests Passing</span>
                    <span class="badge badge-info">Production Ready</span>
                </div>
            </div>

            <!-- Introduction -->
            <section id="introduction" class="section">
                <h2>Introduction</h2>
                <p>CapabilityMesh is the <strong>first and only Python package</strong> providing universal capability discovery and negotiation across all major agent frameworks including CrewAI, AutoGen, LangGraph, A2A, and custom agents.</p>

                <div class="alert alert-info">
                    <strong>üéØ Core Value:</strong> Build multi-agent systems where agents from different frameworks can discover and collaborate with each other seamlessly.
                </div>

                <h3>What Makes CapabilityMesh Unique?</h3>
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>üîç Universal Discovery</h4>
                        <p>Discover agents across ANY framework with semantic search and natural language queries.</p>
                    </div>
                    <div class="feature-card">
                        <h4>ü§ù Multi-Framework</h4>
                        <p>Works with CrewAI, AutoGen, LangGraph, A2A, and custom agents in the same workflow.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üõ°Ô∏è Built-in Trust</h4>
                        <p>Automatic trust scoring based on execution success rates with 5 trust levels.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üíæ Flexible Storage</h4>
                        <p>InMemory, SQLite with FTS5, or Redis backends for any deployment scenario.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üß† Semantic Search</h4>
                        <p>Find agents using natural language, not just keyword matching.</p>
                    </div>
                    <div class="feature-card">
                        <h4>‚ö° Zero Config</h4>
                        <p>Works out of the box with sensible defaults. 5 lines to working discovery!</p>
                    </div>
                </div>

                <h3>Problem: Framework Fragmentation</h3>
                <p>Today's multi-agent ecosystem is fragmented:</p>
                <ul>
                    <li>CrewAI agents can't discover AutoGen agents</li>
                    <li>LangGraph workflows can't find A2A services</li>
                    <li>No standard way to query "which agents can translate?"</li>
                    <li>Manual integration required for every framework pair</li>
                    <li>No trust or reputation across frameworks</li>
                </ul>

                <h3>Solution: CapabilityMesh</h3>
                <p>CapabilityMesh provides a universal discovery layer that works with ALL frameworks:</p>
                <ul>
                    <li>‚úÖ Register agents from any framework</li>
                    <li>‚úÖ Discover capabilities with natural language</li>
                    <li>‚úÖ Track trust and reliability automatically</li>
                    <li>‚úÖ Store agents in memory, SQLite, or Redis</li>
                    <li>‚úÖ Execute tasks through unified interface</li>
                    <li>‚úÖ A2A protocol compatible</li>
                </ul>
            </section>

            <!-- Installation -->
            <section id="installation" class="section">
                <h2>Installation</h2>

                <h3>Core Package</h3>
                <pre><code># Basic installation (includes semantic search, trust, in-memory storage)
pip install capabilitymesh</code></pre>

                <h3>With Optional Dependencies</h3>
                <pre><code># SQLite persistence with full-text search
pip install capabilitymesh[sqlite]

# Redis for distributed discovery (see DISCOVERY_ARCHITECTURE.md)
pip install capabilitymesh[redis]

# Framework integrations
pip install capabilitymesh[crewai]
pip install capabilitymesh[autogen]
pip install capabilitymesh[langgraph]

# Everything
pip install capabilitymesh[all]</code></pre>

                <h3>Requirements</h3>
                <ul>
                    <li>Python 3.9+</li>
                    <li>Core dependencies: pydantic, httpx, cryptography, pyjwt, nest-asyncio</li>
                    <li>Optional: aiosqlite, redis, sentence-transformers</li>
                </ul>

                <div class="alert alert-success">
                    <strong>‚úÖ Verified:</strong> Tested on Python 3.9, 3.10, 3.11, and 3.12. All 137 tests passing on Windows, macOS, and Linux.
                </div>
            </section>

            <!-- Quick Start -->
            <section id="quick-start" class="section">
                <h2>Quick Start</h2>
                <p>Get started with CapabilityMesh in just 5 lines of code:</p>

                <pre><code>from capabilitymesh import Mesh

mesh = Mesh()  # Zero-config, works immediately!

@mesh.agent(name="translator", capabilities=["translation", "nlp"])
def translate(text: str, target_lang: str = "es") -> str:
    return f"[Translated to {target_lang}]: {text}"

# Discover agents with natural language
agents = await mesh.discover("translate text to Spanish")
result = await mesh.execute(agents[0].id, "Hello world!", target_lang="es")</code></pre>

                <div class="alert alert-info">
                    <strong>üí° That's it!</strong> No configuration, no setup, no complexity. Just register and discover.
                </div>

                <h3>Complete Example</h3>
                <pre><code>import asyncio
from capabilitymesh import Mesh, TrustLevel

async def main():
    # Initialize mesh
    mesh = Mesh()

    # Register multiple agents
    @mesh.agent(name="summarizer", capabilities=["summarization", "nlp"])
    async def summarize(text: str) -> str:
        return f"Summary: {text[:100]}..."

    @mesh.agent(name="translator", capabilities=["translation", "nlp"])
    def translate(text: str, target_lang: str = "es") -> str:
        return f"[{target_lang}] {text}"

    @mesh.agent(name="analyzer", capabilities=["sentiment-analysis", "nlp"])
    def analyze_sentiment(text: str) -> dict:
        return {"sentiment": "positive", "confidence": 0.95}

    # List all agents
    agents = await mesh.list_agents()
    print(f"Registered agents: {len(agents)}")

    # Discover by semantic query
    nlp_agents = await mesh.discover("process natural language")
    print(f"NLP agents: {[a.name for a in nlp_agents]}")

    # Execute tasks
    result = await mesh.execute(nlp_agents[0].id, "Long text to summarize...")
    print(f"Result: {result}")

    # Check trust scores
    trust_score = await mesh.trust.get_score(nlp_agents[0].id)
    print(f"Trust: {trust_score.level.name}")

if __name__ == "__main__":
    asyncio.run(main())</code></pre>

                <div class="alert alert-info">
                    <strong>üí° Deployment Note:</strong> This example runs in a single process with all agents in memory. For distributed systems (microservices, multi-process deployments), see <a href="https://github.com/scionoftech/capabilitymesh/blob/main/DISCOVERY_ARCHITECTURE.md" target="_blank">Discovery Architecture</a> for patterns using Redis storage and A2A adapters.
                </div>
            </section>

            <!-- Key Concepts -->
            <section id="key-concepts" class="section">
                <h2>Key Concepts</h2>

                <h3>1. Mesh</h3>
                <p>The <code>Mesh</code> is the central hub that manages all agents, capabilities, and coordination. It provides a unified interface for registration, discovery, and execution.</p>

                <h3>2. Capabilities</h3>
                <p>Capabilities describe what an agent can do. They can be simple strings ("translation") or rich objects with schemas, versioning, and constraints.</p>

                <h3>3. Discovery</h3>
                <p>Discovery is the process of finding agents that match a query. CapabilityMesh supports both exact matching and semantic search using natural language.</p>

                <h3>4. Trust</h3>
                <p>Trust scores track agent reliability based on execution results. Scores auto-adjust from UNTRUSTED to VERIFIED based on success rates.</p>

                <h3>5. Storage</h3>
                <p>Storage backends persist agent registrations. CapabilityMesh supports InMemory (default), SQLite (with FTS5), and Redis.</p>

                <h3>Architecture Overview</h3>
                <pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Mesh                     ‚îÇ
‚îÇ  (Central hub for all operations)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ              ‚îÇ              ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  Storage   ‚îÇ ‚îÇ Embedder  ‚îÇ ‚îÇ   Trust   ‚îÇ
    ‚îÇ  Backend   ‚îÇ ‚îÇ (Search)  ‚îÇ ‚îÇ  Manager  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ              ‚îÇ              ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ         Agent Registry                  ‚îÇ
    ‚îÇ  (Framework-agnostic storage)           ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
            </section>

            <!-- Mesh API -->
            <section id="mesh-api" class="section">
                <h2>Mesh API</h2>
                <p>The <code>Mesh</code> class is the main entry point for CapabilityMesh.</p>

                <h3>Constructor</h3>
                <div class="api-method">
                    <h4>Mesh.__init__()</h4>
                    <div class="api-signature">
                        <code>Mesh(storage=None, embedder=None, trust_manager=None)</code>
                    </div>
                    <p>Initialize a new Mesh instance.</p>
                    <div class="param-list">
                        <div class="param-item">
                            <span class="param-name">storage</span>
                            <span class="param-type">Optional[Storage]</span>
                            <p>Storage backend for agent persistence. Defaults to InMemoryStorage().</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">embedder</span>
                            <span class="param-type">Optional[Embedder]</span>
                            <p>Embedder for semantic search. Auto-selected if None (uses KeywordEmbedder by default).</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">trust_manager</span>
                            <span class="param-type">Optional[SimpleTrustManager]</span>
                            <p>Trust manager for tracking reliability. Auto-created if None.</p>
                        </div>
                    </div>
                    <p><strong>Example:</strong></p>
                    <pre><code>from capabilitymesh import Mesh
from capabilitymesh.storage import SQLiteStorage

# Default (in-memory)
mesh = Mesh()

# With SQLite persistence
mesh = Mesh(storage=SQLiteStorage("agents.db"))</code></pre>
                </div>

                <h3>Registration Methods</h3>

                <div class="api-method">
                    <h4>mesh.register()</h4>
                    <div class="api-signature">
                        <code>async def register(agent, name=None, capabilities=None, agent_type=None, metadata=None) -> AgentIdentity</code>
                    </div>
                    <p>Register an agent with the mesh.</p>
                    <div class="param-list">
                        <div class="param-item">
                            <span class="param-name">agent</span>
                            <span class="param-type">Any</span>
                            <p>Agent to register (function, class, or framework agent)</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">name</span>
                            <span class="param-type">Optional[str]</span>
                            <p>Agent name (auto-generated if None)</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">capabilities</span>
                            <span class="param-type">Optional[List[str | Capability]]</span>
                            <p>List of capabilities (strings or Capability objects)</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">agent_type</span>
                            <span class="param-type">Optional[AgentType]</span>
                            <p>Agent type (auto-detected from framework if None)</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">metadata</span>
                            <span class="param-type">Optional[Dict]</span>
                            <p>Additional metadata</p>
                        </div>
                    </div>
                    <p><strong>Returns:</strong> <code>AgentIdentity</code> - The identity of the registered agent</p>
                    <p><strong>Example:</strong></p>
                    <pre><code># Register a function
def my_agent(task: str) -> str:
    return f"Processed: {task}"

identity = await mesh.register(
    agent=my_agent,
    name="my-agent",
    capabilities=["processing", "task-execution"]
)</code></pre>
                </div>

                <div class="api-method">
                    <h4>@mesh.agent()</h4>
                    <div class="api-signature">
                        <code>@mesh.agent(name=None, capabilities=None, agent_type=None, metadata=None)</code>
                    </div>
                    <p>Decorator for registering agent functions.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>@mesh.agent(name="translator", capabilities=["translation", "nlp"])
def translate(text: str, target_lang: str = "es") -> str:
    return f"[{target_lang}] {text}"

# Async functions work too!
@mesh.agent(name="analyzer", capabilities=["analysis"])
async def analyze(data: dict) -> dict:
    await asyncio.sleep(0.1)  # Async processing
    return {"result": "analyzed"}</code></pre>
                </div>

                <h3>Discovery Methods</h3>

                <div class="api-method">
                    <h4>mesh.discover()</h4>
                    <div class="api-signature">
                        <code>async def discover(query, limit=5, filters=None, min_similarity=0.001, min_trust=None) -> List[AgentInfo]</code>
                    </div>
                    <p>Discover agents matching a query using semantic search.</p>
                    <div class="param-list">
                        <div class="param-item">
                            <span class="param-name">query</span>
                            <span class="param-type">str</span>
                            <p>Search query (natural language or keyword)</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">limit</span>
                            <span class="param-type">int</span>
                            <p>Maximum number of results (default: 5)</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">filters</span>
                            <span class="param-type">Optional[Dict]</span>
                            <p>Additional filters (agent_type, tags, etc.)</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">min_similarity</span>
                            <span class="param-type">float</span>
                            <p>Minimum similarity score (0.0 - 1.0, default: 0.001)</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">min_trust</span>
                            <span class="param-type">Optional[TrustLevel]</span>
                            <p>Minimum trust level (filters by trust)</p>
                        </div>
                    </div>
                    <p><strong>Returns:</strong> <code>List[AgentInfo]</code> - List of matching agents</p>
                    <p><strong>Example:</strong></p>
                    <pre><code># Natural language query
agents = await mesh.discover("translate text to Spanish")

# With filters
agents = await mesh.discover(
    "data processing",
    limit=10,
    min_trust=TrustLevel.MEDIUM
)

# Keyword match
agents = await mesh.discover("nlp", limit=5)</code></pre>
                </div>

                <div class="api-method">
                    <h4>mesh.list_agents()</h4>
                    <div class="api-signature">
                        <code>async def list_agents() -> List[AgentInfo]</code>
                    </div>
                    <p>List all registered agents.</p>
                    <p><strong>Returns:</strong> <code>List[AgentInfo]</code> - All registered agents</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>agents = await mesh.list_agents()
for agent in agents:
    print(f"{agent.name}: {[c.name for c in agent.capabilities]}")</code></pre>
                </div>

                <h3>Execution Methods</h3>

                <div class="api-method">
                    <h4>mesh.execute()</h4>
                    <div class="api-signature">
                        <code>async def execute(agent_id, task, **kwargs) -> Any</code>
                    </div>
                    <p>Execute a task with an agent. Automatically tracks trust scores.</p>
                    <div class="param-list">
                        <div class="param-item">
                            <span class="param-name">agent_id</span>
                            <span class="param-type">str</span>
                            <p>Agent's unique identifier</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">task</span>
                            <span class="param-type">Any</span>
                            <p>Task data to execute</p>
                        </div>
                        <div class="param-item">
                            <span class="param-name">**kwargs</span>
                            <span class="param-type">Any</span>
                            <p>Additional parameters passed to agent</p>
                        </div>
                    </div>
                    <p><strong>Returns:</strong> Result from agent execution</p>
                    <p><strong>Raises:</strong> <code>ExecutionError</code> if execution fails</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>agents = await mesh.discover("translation")
if agents:
    result = await mesh.execute(
        agents[0].id,
        "Hello world",
        target_lang="fr"
    )
    print(result)  # "[fr] Hello world"</code></pre>
                </div>

                <div class="api-method">
                    <h4>mesh.get_native()</h4>
                    <div class="api-signature">
                        <code>def get_native(agent_id) -> Any</code>
                    </div>
                    <p>Get the native agent object (function, class, or framework agent).</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>native_func = mesh.get_native(agent_id)
if native_func:
    result = native_func("direct call")  # Call directly</code></pre>
                </div>
            </section>

            <!-- AgentInfo -->
            <section id="agent-info" class="section">
                <h2>AgentInfo</h2>
                <p>Information about a registered agent returned from discovery methods.</p>

                <h3>Attributes</h3>
                <table>
                    <tr>
                        <th>Attribute</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><code>id</code></td>
                        <td>str</td>
                        <td>Unique agent identifier (UUID)</td>
                    </tr>
                    <tr>
                        <td><code>name</code></td>
                        <td>str</td>
                        <td>Human-readable agent name</td>
                    </tr>
                    <tr>
                        <td><code>agent_type</code></td>
                        <td>AgentType</td>
                        <td>Agent type (FUNCTION, SERVICE, A2A, etc.)</td>
                    </tr>
                    <tr>
                        <td><code>capabilities</code></td>
                        <td>List[Capability]</td>
                        <td>List of agent capabilities</td>
                    </tr>
                    <tr>
                        <td><code>metadata</code></td>
                        <td>Dict</td>
                        <td>Additional metadata</td>
                    </tr>
                    <tr>
                        <td><code>registered_at</code></td>
                        <td>datetime</td>
                        <td>Registration timestamp</td>
                    </tr>
                </table>

                <p><strong>Example:</strong></p>
                <pre><code>agents = await mesh.discover("translation")
for agent in agents:
    print(f"ID: {agent.id}")
    print(f"Name: {agent.name}")
    print(f"Type: {agent.agent_type}")
    print(f"Capabilities: {[c.name for c in agent.capabilities]}")
    print(f"Registered: {agent.registered_at}")</code></pre>
            </section>

            <!-- Capability API -->
            <section id="capability-api" class="section">
                <h2>Capability API</h2>
                <p>Capabilities define what agents can do. They can be simple strings or rich objects with schemas, versioning, and constraints.</p>

                <h3>Simple Capabilities</h3>
                <p>The quickest way is to use string capabilities:</p>
                <pre><code>@mesh.agent(capabilities=["translation", "nlp", "language"])
def my_agent(text: str) -> str:
    return text</code></pre>

                <h3>Rich Capabilities</h3>
                <p>For production systems, use the full <code>Capability</code> class:</p>

                <div class="api-method">
                    <h4>Capability.create_simple()</h4>
                    <div class="api-signature">
                        <code>Capability.create_simple(name, description="", tags=[], version="1.0.0")</code>
                    </div>
                    <p>Create a simple capability with minimal configuration.</p>
                    <p><strong>Example:</strong></p>
                    <pre><code>from capabilitymesh import Capability

capability = Capability.create_simple(
    name="text-summarization",
    description="Summarize long documents into key points",
    tags=["nlp", "summarization", "text-processing"],
    version="2.1.0"
)</code></pre>
                </div>

                <h3>Advanced Capability Features</h3>

                <h4>1. Capability Versioning</h4>
                <pre><code>from capabilitymesh import Capability, CapabilityVersion

capability = Capability(
    name="translate-v2",
    version=CapabilityVersion(major=2, minor=1, patch=0),
    description="Translation with context awareness"
)

# Check compatibility
v1 = CapabilityVersion(major=1, minor=0, patch=0)
v2 = CapabilityVersion(major=2, minor=0, patch=0)
print(v1.is_compatible(v2))  # False (different major version)</code></pre>

                <h4>2. Performance Constraints</h4>
                <pre><code>from capabilitymesh import Capability, CapabilityConstraints

capability = Capability(
    name="fast-translation",
    constraints=CapabilityConstraints(
        max_response_time_ms=100,     # Must respond in 100ms
        max_cost_per_call=0.001,       # Max $0.001 per call
        min_availability=0.999,        # 99.9% uptime
        rate_limit_per_minute=1000     # 1000 calls/minute
    )
)</code></pre>

                <h4>3. Semantic Metadata</h4>
                <pre><code>from capabilitymesh import Capability, SemanticMetadata

capability = Capability(
    name="ml-translation",
    semantic=SemanticMetadata(
        tags=["nlp", "translation", "ml"],
        categories=["Natural Language Processing", "Machine Learning"],
        domains=["linguistics", "ai"],
        keywords=["translate", "language", "convert"]
    )
)</code></pre>

                <h4>4. Input/Output Schemas</h4>
                <pre><code>from capabilitymesh import (
    Capability,
    CapabilityInputOutput,
    IOFormat
)

capability = Capability(
    name="structured-api",
    input_spec=CapabilityInputOutput(
        format=IOFormat.JSON,
        json_schema={
            "type": "object",
            "properties": {
                "text": {"type": "string"},
                "language": {"type": "string"}
            },
            "required": ["text"]
        },
        description="Input must be JSON with text and optional language"
    ),
    output_spec=CapabilityInputOutput(
        format=IOFormat.JSON,
        json_schema={
            "type": "object",
            "properties": {
                "translated": {"type": "string"},
                "confidence": {"type": "number"}
            }
        },
        description="Returns translated text with confidence score"
    )
)</code></pre>
            </section>

            <!-- Identity API -->
            <section id="identity-api" class="section">
                <h2>Identity & Address API</h2>
                <p>Every agent has a unique identity and one or more network addresses.</p>

                <h3>AgentIdentity</h3>
                <p>Unique identifier for an agent with cryptographic capabilities.</p>

                <table>
                    <tr>
                        <th>Attribute</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><code>id</code></td>
                        <td>str</td>
                        <td>Unique identifier (UUID)</td>
                    </tr>
                    <tr>
                        <td><code>name</code></td>
                        <td>str</td>
                        <td>Human-readable name</td>
                    </tr>
                    <tr>
                        <td><code>agent_type</code></td>
                        <td>AgentType</td>
                        <td>Type of agent</td>
                    </tr>
                    <tr>
                        <td><code>public_key</code></td>
                        <td>Optional[str]</td>
                        <td>RSA public key (PEM format)</td>
                    </tr>
                    <tr>
                        <td><code>addresses</code></td>
                        <td>List[AgentAddress]</td>
                        <td>Network addresses</td>
                    </tr>
                </table>

                <h3>AgentAddress</h3>
                <p>Network address for communicating with an agent.</p>

                <table>
                    <tr>
                        <th>Attribute</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><code>protocol</code></td>
                        <td>str</td>
                        <td>Protocol (http, grpc, mqtt, etc.)</td>
                    </tr>
                    <tr>
                        <td><code>host</code></td>
                        <td>str</td>
                        <td>Hostname or IP</td>
                    </tr>
                    <tr>
                        <td><code>port</code></td>
                        <td>int</td>
                        <td>Port number</td>
                    </tr>
                    <tr>
                        <td><code>path</code></td>
                        <td>Optional[str]</td>
                        <td>Path (for HTTP/REST)</td>
                    </tr>
                </table>

                <p><strong>Example:</strong></p>
                <pre><code>from capabilitymesh import AgentIdentity, AgentAddress, AgentType

identity = AgentIdentity(
    name="my-service",
    agent_type=AgentType.SERVICE,
    addresses=[
        AgentAddress(
            protocol="http",
            host="api.example.com",
            port=8080,
            path="/agent/execute"
        )
    ]
)</code></pre>
            </section>

            <!-- Storage Overview -->
            <section id="storage-overview" class="section">
                <h2>Storage Backends</h2>
                <p>CapabilityMesh supports multiple storage backends for different deployment scenarios.</p>

                <h3>Comparison</h3>
                <table>
                    <tr>
                        <th>Backend</th>
                        <th>Persistence</th>
                        <th>Search</th>
                        <th>Distribution</th>
                        <th>Best For</th>
                    </tr>
                    <tr>
                        <td><strong>InMemory</strong></td>
                        <td>No</td>
                        <td>Basic</td>
                        <td>Single process</td>
                        <td>Development, testing</td>
                    </tr>
                    <tr>
                        <td><strong>SQLite</strong></td>
                        <td>Yes (file)</td>
                        <td>Full-text (FTS5)</td>
                        <td>Single instance</td>
                        <td>Production (single server)</td>
                    </tr>
                    <tr>
                        <td><strong>Redis</strong></td>
                        <td>Yes (remote)</td>
                        <td>Basic</td>
                        <td>Multi-instance</td>
                        <td>Distributed systems, cloud</td>
                    </tr>
                </table>

                <h3>When to Use Each</h3>
                <ul>
                    <li><strong>InMemory</strong>: Fast development, unit tests, ephemeral agents</li>
                    <li><strong>SQLite</strong>: Production single-instance, excellent search, file-based</li>
                    <li><strong>Redis</strong>: Microservices, horizontal scaling, shared registry</li>
                </ul>

                <div class="alert alert-info">
                    <strong>üìò Discovery Architecture:</strong> Redis enables <strong>discovery</strong> across multiple processes/machines, but <strong>execution</strong> is process-local for Python functions. For true distributed execution, use A2A adapters (HTTP-based agents). See <a href="https://github.com/scionoftech/capabilitymesh/blob/main/DISCOVERY_ARCHITECTURE.md" target="_blank">Discovery Architecture Guide</a> for deployment patterns.
                </div>
            </section>

            <!-- InMemory Storage -->
            <section id="inmemory-storage" class="section">
                <h2>InMemory Storage</h2>
                <p>Default storage backend. Fast, simple, no persistence.</p>

                <h3>Usage</h3>
                <pre><code>from capabilitymesh import Mesh, InMemoryStorage

# Automatic (default)
mesh = Mesh()

# Explicit
mesh = Mesh(storage=InMemoryStorage())</code></pre>

                <h3>Characteristics</h3>
                <ul>
                    <li>‚úÖ Zero configuration</li>
                    <li>‚úÖ Fastest performance</li>
                    <li>‚úÖ Perfect for development</li>
                    <li>‚ùå No persistence (data lost on restart)</li>
                    <li>‚ùå Single process only</li>
                </ul>

                <div class="alert alert-info">
                    <strong>üí° Tip:</strong> InMemory is perfect for getting started and unit tests. Switch to SQLite for production.
                </div>
            </section>

            <!-- SQLite Storage -->
            <section id="sqlite-storage" class="section">
                <h2>SQLite Storage</h2>
                <p>File-based persistence with FTS5 full-text search.</p>

                <h3>Installation</h3>
                <pre><code>pip install capabilitymesh[sqlite]</code></pre>

                <h3>Usage</h3>
                <pre><code>from capabilitymesh import Mesh
from capabilitymesh.storage import SQLiteStorage

# File-based
mesh = Mesh(storage=SQLiteStorage("agents.db"))

# In-memory SQLite (for testing)
mesh = Mesh(storage=SQLiteStorage(":memory:"))</code></pre>

                <h3>Features</h3>
                <ul>
                    <li>‚úÖ File-based persistence</li>
                    <li>‚úÖ FTS5 full-text search</li>
                    <li>‚úÖ SQL queries for complex filters</li>
                    <li>‚úÖ ACID transactions</li>
                    <li>‚úÖ No external dependencies</li>
                </ul>

                <h3>Full-Text Search</h3>
                <p>SQLite storage automatically indexes agents for fast full-text search:</p>
                <pre><code># Search by name, description, or capabilities
agents = await mesh.discover("translate natural language processing")

# FTS5 finds matches in:
# - Agent name
# - Agent description
# - All capability names and descriptions</code></pre>

                <h3>Database Schema</h3>
                <pre><code>-- Agents table
CREATE TABLE agents (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    agent_type TEXT NOT NULL,
    description TEXT,
    registered_at TIMESTAMP,
    metadata TEXT  -- JSON
);

-- Capabilities table
CREATE TABLE capabilities (
    id TEXT PRIMARY KEY,
    agent_id TEXT,
    name TEXT NOT NULL,
    description TEXT,
    capability_data TEXT,  -- JSON
    FOREIGN KEY(agent_id) REFERENCES agents(id)
);

-- Trust scores table
CREATE TABLE trust_scores (
    agent_id TEXT PRIMARY KEY,
    trust_level INTEGER,
    success_count INTEGER,
    failure_count INTEGER,
    total_executions INTEGER,
    last_execution TIMESTAMP,
    FOREIGN KEY(agent_id) REFERENCES agents(id)
);

-- FTS5 full-text search index
CREATE VIRTUAL TABLE agents_fts USING fts5(
    agent_id UNINDEXED,
    name,
    description,
    capabilities  -- concatenated capability names
);</code></pre>

                <div class="alert alert-success">
                    <strong>‚úÖ Recommended:</strong> SQLite is the recommended storage for production single-instance deployments. It's fast, reliable, and requires no external services.
                </div>
            </section>

            <!-- Redis Storage -->
            <section id="redis-storage" class="section">
                <h2>Redis Storage</h2>
                <p>Distributed storage for multi-instance deployments.</p>

                <h3>Installation</h3>
                <pre><code>pip install capabilitymesh[redis]</code></pre>

                <h3>Usage</h3>
                <pre><code>from capabilitymesh import Mesh
from capabilitymesh.storage import RedisStorage

# Connect to Redis
mesh = Mesh(storage=RedisStorage(
    host="localhost",
    port=6379,
    db=0,
    password=None,  # Optional
    prefix="capabilitymesh:",  # Key prefix
    ttl=None  # Optional TTL in seconds
))</code></pre>

                <h3>Features</h3>
                <ul>
                    <li>‚úÖ Distributed storage (multiple instances)</li>
                    <li>‚úÖ Horizontal scaling</li>
                    <li>‚úÖ High availability (Redis Cluster)</li>
                    <li>‚úÖ Optional TTL for ephemeral agents</li>
                    <li>‚úÖ Pub/sub for real-time updates</li>
                </ul>

                <h3>Redis Key Schema</h3>
                <pre><code># Agent data
capabilitymesh:agents:{agent_id}  -> Hash

# Capabilities
capabilitymesh:capabilities:{cap_id}  -> Hash

# Agent ID index
capabilitymesh:agent_ids  -> Set

# Trust scores
capabilitymesh:trust:{agent_id}  -> Hash</code></pre>

                <h3>Multi-Instance Setup</h3>
                <pre><code># Instance 1
mesh1 = Mesh(storage=RedisStorage(host="redis.example.com"))
await mesh1.register(agent1)

# Instance 2 (sees agent1!)
mesh2 = Mesh(storage=RedisStorage(host="redis.example.com"))
agents = await mesh2.list_agents()  # Contains agent1!</code></pre>

                <div class="alert alert-warning">
                    <strong>‚ö†Ô∏è Note:</strong> Requires a running Redis server. Start with: <code>redis-server</code> or use Docker: <code>docker run -d -p 6379:6379 redis</code>
                </div>

                <div class="alert alert-info">
                    <strong>üìò Important:</strong> This example shows cross-process <strong>discovery</strong>. Instance 2 can discover agents registered by Instance 1. However, <strong>execution</strong> is process-local - Instance 2 cannot execute Instance 1's Python functions directly. For distributed execution:
                    <ul style="margin-top: 10px;">
                        <li>Use A2A adapters for HTTP-based agents</li>
                        <li>Implement custom RPC/message queue coordination</li>
                        <li>See <a href="https://github.com/scionoftech/capabilitymesh/blob/main/DISCOVERY_ARCHITECTURE.md" target="_blank">Discovery Architecture</a> for patterns</li>
                    </ul>
                </div>
            </section>

            <!-- Trust System -->
            <section id="trust-system" class="section">
                <h2>Trust Management</h2>
                <p>CapabilityMesh includes a built-in trust system that automatically tracks agent reliability based on execution results.</p>

                <h3>How It Works</h3>
                <ol>
                    <li>Every time you call <code>mesh.execute()</code>, the result (success/failure) is recorded</li>
                    <li>Trust scores automatically adjust based on success rate and execution count</li>
                    <li>You can filter discovery by minimum trust level</li>
                    <li>Manual trust levels can override automatic calculations</li>
                </ol>

                <h3>Automatic Trust Tracking</h3>
                <pre><code>from capabilitymesh import Mesh

mesh = Mesh()

@mesh.agent(name="reliable", capabilities=["task"])
def reliable_agent(x):
    return x * 2  # Always succeeds

@mesh.agent(name="unstable", capabilities=["task"])
def unstable_agent(x):
    if x % 2 == 0:
        raise ValueError("Failed!")
    return x * 2

# Execute multiple times
for i in range(20):
    try:
        await mesh.execute(reliable_id, i)
        await mesh.execute(unstable_id, i)
    except:
        pass  # unstable_agent fails 50% of the time

# Check trust scores
reliable_score = await mesh.trust.get_score(reliable_id)
print(f"Reliable: {reliable_score.level.name}")  # HIGH or VERIFIED
print(f"Success rate: {reliable_score.success_rate:.1%}")  # ~100%

unstable_score = await mesh.trust.get_score(unstable_id)
print(f"Unstable: {unstable_score.level.name}")  # LOW or MEDIUM
print(f"Success rate: {unstable_score.success_rate:.1%}")  # ~50%</code></pre>

                <h3>Trust-Based Discovery</h3>
                <pre><code>from capabilitymesh import TrustLevel

# Only discover agents with MEDIUM or higher trust
trusted_agents = await mesh.discover(
    "task processing",
    min_trust=TrustLevel.MEDIUM
)

# Only get highly trusted agents
verified_agents = await mesh.discover(
    "critical operations",
    min_trust=TrustLevel.HIGH
)</code></pre>
            </section>

            <!-- Trust Levels -->
            <section id="trust-levels" class="section">
                <h2>Trust Levels</h2>
                <p>CapabilityMesh uses a 5-level trust system:</p>

                <table>
                    <tr>
                        <th>Level</th>
                        <th>Value</th>
                        <th>Criteria</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><strong>UNTRUSTED</strong></td>
                        <td>0</td>
                        <td>Never executed</td>
                        <td>New agents start here</td>
                    </tr>
                    <tr>
                        <td><strong>LOW</strong></td>
                        <td>1</td>
                        <td>&lt; 50% success OR &lt; 5 executions</td>
                        <td>Unreliable or untested</td>
                    </tr>
                    <tr>
                        <td><strong>MEDIUM</strong></td>
                        <td>2</td>
                        <td>50-80% success, ‚â• 5 executions</td>
                        <td>Moderately reliable</td>
                    </tr>
                    <tr>
                        <td><strong>HIGH</strong></td>
                        <td>3</td>
                        <td>80-95% success, ‚â• 10 executions</td>
                        <td>Very reliable</td>
                    </tr>
                    <tr>
                        <td><strong>VERIFIED</strong></td>
                        <td>4</td>
                        <td>&gt; 95% success, ‚â• 20 executions OR manual</td>
                        <td>Extremely reliable or manually verified</td>
                    </tr>
                </table>

                <h3>Trust Level Progression</h3>
                <pre><code>UNTRUSTED (0 executions)
    ‚Üì
LOW (< 5 executions OR low success rate)
    ‚Üì
MEDIUM (5+ executions, 50-80% success)
    ‚Üì
HIGH (10+ executions, 80-95% success)
    ‚Üì
VERIFIED (20+ executions, > 95% success OR manually set)</code></pre>

                <div class="alert alert-info">
                    <strong>üí° Note:</strong> Trust levels are auto-calculated unless manually set. Manual trust levels are never overridden by auto-calculation.
                </div>
            </section>

            <!-- Trust API -->
            <section id="trust-api" class="section">
                <h2>Trust API</h2>

                <h3>SimpleTrustManager</h3>
                <p>Accessible via <code>mesh.trust</code>.</p>

                <div class="api-method">
                    <h4>mesh.trust.get_score()</h4>
                    <div class="api-signature">
                        <code>async def get_score(agent_id: str) -> TrustScore</code>
                    </div>
                    <p>Get trust score for an agent.</p>
                    <p><strong>Returns:</strong> <code>TrustScore</code> object with metrics</p>
                    <pre><code>score = await mesh.trust.get_score(agent_id)
print(f"Level: {score.level.name}")
print(f"Success rate: {score.success_rate:.1%}")
print(f"Total executions: {score.total_executions}")
print(f"Last execution: {score.last_execution}")</code></pre>
                </div>

                <div class="api-method">
                    <h4>mesh.trust.set_level()</h4>
                    <div class="api-signature">
                        <code>async def set_level(agent_id: str, level: TrustLevel, reason: str = None)</code>
                    </div>
                    <p>Manually set trust level (overrides auto-calculation).</p>
                    <pre><code>from capabilitymesh import TrustLevel

# Manually verify an agent
await mesh.trust.set_level(
    agent_id,
    TrustLevel.VERIFIED,
    reason="Passed security audit"
)

# Blacklist an agent
await mesh.trust.set_level(
    agent_id,
    TrustLevel.UNTRUSTED,
    reason="Security vulnerability found"
)</code></pre>
                </div>

                <div class="api-method">
                    <h4>mesh.trust.record_execution()</h4>
                    <div class="api-signature">
                        <code>async def record_execution(agent_id: str, success: bool, duration: float = 0.0)</code>
                    </div>
                    <p>Record execution result. <strong>Automatically called by mesh.execute()</strong>.</p>
                    <pre><code># Usually you don't call this directly, but you can:
await mesh.trust.record_execution(agent_id, success=True, duration=0.123)</code></pre>
                </div>

                <div class="api-method">
                    <h4>mesh.trust.list_trusted()</h4>
                    <div class="api-signature">
                        <code>async def list_trusted(min_level: TrustLevel = TrustLevel.MEDIUM) -> List[TrustScore]</code>
                    </div>
                    <p>List all agents meeting minimum trust level.</p>
                    <pre><code># Get all highly trusted agents
trusted = await mesh.trust.list_trusted(TrustLevel.HIGH)
for score in trusted:
    print(f"{score.agent_id}: {score.level.name} ({score.success_rate:.0%})")</code></pre>
                </div>

                <h3>TrustScore Object</h3>
                <table>
                    <tr>
                        <th>Attribute</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><code>agent_id</code></td>
                        <td>str</td>
                        <td>Agent identifier</td>
                    </tr>
                    <tr>
                        <td><code>level</code></td>
                        <td>TrustLevel</td>
                        <td>Current trust level</td>
                    </tr>
                    <tr>
                        <td><code>success_count</code></td>
                        <td>int</td>
                        <td>Number of successful executions</td>
                    </tr>
                    <tr>
                        <td><code>failure_count</code></td>
                        <td>int</td>
                        <td>Number of failed executions</td>
                    </tr>
                    <tr>
                        <td><code>total_executions</code></td>
                        <td>int</td>
                        <td>Total execution count</td>
                    </tr>
                    <tr>
                        <td><code>success_rate</code></td>
                        <td>float</td>
                        <td>Success rate (0.0 - 1.0)</td>
                    </tr>
                    <tr>
                        <td><code>last_execution</code></td>
                        <td>datetime</td>
                        <td>Timestamp of last execution</td>
                    </tr>
                    <tr>
                        <td><code>manually_set</code></td>
                        <td>bool</td>
                        <td>Whether level was manually set</td>
                    </tr>
                </table>
            </section>

            <!-- Embeddings -->
            <section id="embeddings" class="section">
                <h2>Embeddings & Semantic Search</h2>
                <p>CapabilityMesh uses embeddings to enable semantic discovery with natural language queries.</p>

                <h3>Default: KeywordEmbedder</h3>
                <p>By default, CapabilityMesh uses a TF-IDF based keyword embedder that requires no external dependencies:</p>
                <pre><code>from capabilitymesh import Mesh

mesh = Mesh()  # Automatically uses KeywordEmbedder

# Natural language queries work!
agents = await mesh.discover("translate text to Spanish")
agents = await mesh.discover("process natural language")
agents = await mesh.discover("analyze sentiment of reviews")</code></pre>

                <h3>How Semantic Search Works</h3>
                <ol>
                    <li>When you register an agent, its capabilities are embedded into vectors</li>
                    <li>When you search, the query is also embedded</li>
                    <li>Cosine similarity finds the best matches</li>
                    <li>Results are ranked by similarity score</li>
                </ol>

                <h3>Custom Embedders</h3>
                <p>You can provide your own embedder:</p>
                <pre><code>from capabilitymesh import Mesh, Embedder

class MyEmbedder(Embedder):
    async def embed(self, text: str) -> List[float]:
        # Your embedding logic here
        # Could use OpenAI, sentence-transformers, etc.
        return vector

mesh = Mesh(embedder=MyEmbedder())</code></pre>

                <div class="alert alert-info">
                    <strong>üîÆ Coming Soon:</strong> v1.0.0-beta.1 will include LocalEmbedder (sentence-transformers) and OpenAIEmbedder for even better semantic search.
                </div>
            </section>

            <!-- Framework Integration -->
            <section id="framework-integration" class="section">
                <h2>Framework Integration</h2>
                <p>CapabilityMesh works with agents from any framework. Here's how to integrate popular frameworks:</p>

                <h3>CrewAI</h3>
                <pre><code>from capabilitymesh import Mesh
from crewai import Agent as CrewAgent

mesh = Mesh()

# Create CrewAI agent
researcher = CrewAgent(
    role="Senior Research Analyst",
    goal="Uncover cutting-edge developments in AI",
    backstory="Expert researcher with deep domain knowledge",
    verbose=True
)

# Register with CapabilityMesh
await mesh.register(
    researcher,
    name="ai-researcher",
    capabilities=["research", "analysis", "information-gathering"]
)

# Discover and use
agents = await mesh.discover("research AI developments")
# agents[0] is the CrewAI researcher!</code></pre>

                <h3>AutoGen</h3>
                <pre><code>from capabilitymesh import Mesh
from autogen import AssistantAgent, UserProxyAgent

mesh = Mesh()

# Create AutoGen agents
coder = AssistantAgent(
    name="coder",
    system_message="You are an expert Python developer",
    llm_config={"config_list": [...]}
)

reviewer = AssistantAgent(
    name="code_reviewer",
    system_message="You review code for quality and security"
)

# Register with CapabilityMesh
await mesh.register(coder, name="python-coder", capabilities=["coding", "python"])
await mesh.register(reviewer, name="code-reviewer", capabilities=["review", "security"])

# Discover across frameworks
coders = await mesh.discover("write python code")
# Returns AutoGen coder!</code></pre>

                <h3>LangGraph</h3>
                <pre><code>from capabilitymesh import Mesh
from langgraph.graph import StateGraph

mesh = Mesh()

# Create LangGraph workflow
workflow = StateGraph(...)
# ... define nodes and edges ...

# Register with CapabilityMesh
await mesh.register(
    workflow,
    name="data-pipeline",
    capabilities=["data-processing", "workflow", "etl"]
)

# Discover
pipelines = await mesh.discover("process and transform data")</code></pre>

                <h3>A2A Protocol</h3>
                <pre><code>from capabilitymesh import Mesh

mesh = Mesh()

# A2A agents are automatically detected and work seamlessly
# CapabilityMesh can convert any agent to/from A2A format</code></pre>

                <h3>Custom Agents</h3>
                <pre><code>from capabilitymesh import Mesh

mesh = Mesh()

# Any callable works!
class MyAgent:
    def execute(self, task):
        return f"Processed: {task}"

agent = MyAgent()
await mesh.register(agent, name="my-agent", capabilities=["task-processing"])

# Or just functions
@mesh.agent(capabilities=["calculation"])
def calculator(a: int, b: int) -> int:
    return a + b</code></pre>
            </section>

            <!-- Multi-Agent Workflows -->
            <section id="multi-agent-workflows" class="section">
                <h2>Multi-Agent Workflows</h2>
                <p>Coordinate multiple agents to accomplish complex tasks.</p>

                <h3>Sequential Pipeline</h3>
                <pre><code>from capabilitymesh import Mesh

mesh = Mesh()

# Register pipeline agents
@mesh.agent(capabilities=["extraction"])
async def extract(pdf_path):
    return "Extracted text..."

@mesh.agent(capabilities=["summarization"])
async def summarize(text):
    return "Summary..."

@mesh.agent(capabilities=["translation"])
async def translate(text):
    return "Translated..."

# Execute pipeline
pdf = "document.pdf"

extractors = await mesh.discover("extract text from pdf")
text = await mesh.execute(extractors[0].id, pdf)

summarizers = await mesh.discover("summarize text")
summary = await mesh.execute(summarizers[0].id, text)

translators = await mesh.discover("translate to spanish")
result = await mesh.execute(translators[0].id, summary)</code></pre>

                <h3>Parallel Processing</h3>
                <pre><code>import asyncio
from capabilitymesh import Mesh

mesh = Mesh()

# Process multiple items in parallel
items = ["doc1.pdf", "doc2.pdf", "doc3.pdf"]

extractors = await mesh.discover("extract text")
extractor_id = extractors[0].id

# Execute in parallel
results = await asyncio.gather(*[
    mesh.execute(extractor_id, item)
    for item in items
])

# results = ["text1", "text2", "text3"]</code></pre>

                <h3>Conditional Routing</h3>
                <pre><code>from capabilitymesh import Mesh

mesh = Mesh()

async def process_document(doc):
    # Analyze document type
    analyzers = await mesh.discover("analyze document")
    doc_type = await mesh.execute(analyzers[0].id, doc)

    # Route to appropriate handler
    if doc_type == "pdf":
        handlers = await mesh.discover("extract pdf")
    elif doc_type == "image":
        handlers = await mesh.discover("ocr text extraction")
    else:
        handlers = await mesh.discover("generic text extraction")

    return await mesh.execute(handlers[0].id, doc)</code></pre>

                <h3>Error Handling with Fallbacks</h3>
                <pre><code>from capabilitymesh import Mesh, TrustLevel

mesh = Mesh()

async def robust_execution(capability, task):
    # Get agents sorted by trust
    agents = await mesh.discover(
        capability,
        min_trust=TrustLevel.MEDIUM
    )

    # Try agents in order until one succeeds
    for agent in agents:
        try:
            result = await mesh.execute(agent.id, task)
            return result
        except Exception as e:
            print(f"Agent {agent.name} failed: {e}")
            continue

    raise Exception("All agents failed")

# Usage
result = await robust_execution("translation", "Hello world")</code></pre>

                <h3>Fan-Out / Fan-In</h3>
                <pre><code>import asyncio
from capabilitymesh import Mesh

mesh = Mesh()

async def parallel_analysis(text):
    # Fan-out: Send to multiple analyzers
    sentiment_agents = await mesh.discover("sentiment analysis")
    entity_agents = await mesh.discover("entity extraction")
    topic_agents = await mesh.discover("topic classification")

    # Execute all in parallel
    sentiment, entities, topics = await asyncio.gather(
        mesh.execute(sentiment_agents[0].id, text),
        mesh.execute(entity_agents[0].id, text),
        mesh.execute(topic_agents[0].id, text)
    )

    # Fan-in: Combine results
    return {
        "sentiment": sentiment,
        "entities": entities,
        "topics": topics
    }</code></pre>
            </section>

            <!-- Best Practices -->
            <section id="best-practices" class="section">
                <h2>Best Practices</h2>

                <h3>1. Use Descriptive Capability Names</h3>
                <pre><code># Good
capabilities=["translation", "english-to-spanish", "nlp", "language-processing"]

# Less effective
capabilities=["translate", "lang"]</code></pre>

                <h3>2. Add Rich Metadata</h3>
                <pre><code>from capabilitymesh import Capability, SemanticMetadata

capability = Capability(
    name="ml-translation",
    description="Neural machine translation with context awareness",
    semantic=SemanticMetadata(
        tags=["nlp", "translation", "ml", "neural"],
        categories=["Natural Language Processing"],
        domains=["linguistics", "ai"]
    )
)</code></pre>

                <h3>3. Use Trust Levels in Production</h3>
                <pre><code># Always filter by trust in production
agents = await mesh.discover(
    "critical financial calculation",
    min_trust=TrustLevel.HIGH  # Only highly reliable agents
)</code></pre>

                <h3>4. Choose the Right Storage</h3>
                <pre><code># Development
mesh = Mesh()  # InMemory (default)

# Production (single instance)
mesh = Mesh(storage=SQLiteStorage("agents.db"))

# Production (distributed)
mesh = Mesh(storage=RedisStorage(host="redis.example.com"))</code></pre>

                <h3>5. Handle Errors Gracefully</h3>
                <pre><code>from capabilitymesh.core.exceptions import ExecutionError

try:
    result = await mesh.execute(agent_id, task)
except ExecutionError as e:
    print(f"Execution failed: {e}")
    # Try fallback agent
    agents = await mesh.discover(capability)
    result = await mesh.execute(agents[1].id, task)</code></pre>

                <h3>6. Use Async Where Possible</h3>
                <pre><code># Preferred (async)
agents = await mesh.discover("query")
result = await mesh.execute(agent_id, task)

# Sync wrappers available but less efficient
# agents = mesh.discover_sync("query")
# result = mesh.execute_sync(agent_id, task)</code></pre>

                <h3>7. Version Your Capabilities</h3>
                <pre><code>from capabilitymesh import Capability, CapabilityVersion

# Good: Semantic versioning
capability = Capability(
    name="translation-api",
    version=CapabilityVersion(major=2, minor=1, patch=0)
)

# Check compatibility
if capability.version.is_compatible(client_version):
    # Safe to use
    ...</code></pre>

                <h3>8. Monitor Trust Scores</h3>
                <pre><code># Regularly check agent health
async def health_check():
    agents = await mesh.list_agents()
    for agent in agents:
        score = await mesh.trust.get_score(agent.id)
        if score.level < TrustLevel.MEDIUM:
            print(f"‚ö†Ô∏è {agent.name} has low trust: {score.success_rate:.1%}")
        if score.total_executions > 100 and score.success_rate < 0.5:
            print(f"üö® {agent.name} is unreliable, consider removing")</code></pre>
            </section>

            <!-- Examples -->
            <section id="example-basic" class="section">
                <h2>Example: Basic Usage</h2>
                <p>Complete example demonstrating registration, discovery, and execution.</p>

                <pre><code>import asyncio
from capabilitymesh import Mesh, Capability

async def main():
    # Initialize mesh
    mesh = Mesh()

    # Method 1: Register with decorator
    @mesh.agent(name="summarizer", capabilities=["summarization", "nlp"])
    async def summarize(text: str) -> str:
        return f"Summary: {text[:100]}..."

    # Method 2: Register with Capability objects
    capability = Capability.create_simple(
        name="translation",
        description="Translate text between languages",
        tags=["nlp", "language", "translation"]
    )

    @mesh.agent(name="translator", capabilities=[capability])
    def translate(text: str, target_lang: str = "es") -> str:
        return f"[{target_lang}] {text}"

    # Method 3: Register explicitly
    def analyze(text: str) -> dict:
        return {"sentiment": "positive", "confidence": 0.95}

    await mesh.register(
        agent=analyze,
        name="sentiment-analyzer",
        capabilities=["sentiment-analysis", "nlp"]
    )

    # List all agents
    print("\n=== Registered Agents ===")
    agents = await mesh.list_agents()
    for agent in agents:
        caps = ", ".join([c.name for c in agent.capabilities])
        print(f"{agent.name}: [{caps}]")

    # Discover by semantic query
    print("\n=== Discovery ===")
    nlp_agents = await mesh.discover("process natural language")
    print(f"NLP agents: {[a.name for a in nlp_agents]}")

    # Execute tasks
    print("\n=== Execution ===")
    text = "CapabilityMesh is a powerful framework for multi-agent systems."

    # Summarize
    summarizers = await mesh.discover("summarize")
    if summarizers:
        result = await mesh.execute(summarizers[0].id, text)
        print(f"Summary: {result}")

    # Translate
    translators = await mesh.discover("translate")
    if translators:
        result = await mesh.execute(translators[0].id, text, target_lang="fr")
        print(f"Translation: {result}")

    # Analyze sentiment
    analyzers = await mesh.discover("sentiment")
    if analyzers:
        result = await mesh.execute(analyzers[0].id, text)
        print(f"Sentiment: {result}")

if __name__ == "__main__":
    asyncio.run(main())</code></pre>
            </section>

            <section id="example-storage" class="section">
                <h2>Example: Storage Backends</h2>
                <pre><code>import asyncio
from capabilitymesh import Mesh
from capabilitymesh.storage import InMemoryStorage, SQLiteStorage

async def demo_storage():
    print("=== InMemory Storage ===")
    mesh1 = Mesh(storage=InMemoryStorage())

    @mesh1.agent(capabilities=["task"])
    def agent1(x):
        return x * 2

    agents = await mesh1.list_agents()
    print(f"Agents: {len(agents)}")

    print("\n=== SQLite Storage ===")
    mesh2 = Mesh(storage=SQLiteStorage("demo.db"))

    @mesh2.agent(capabilities=["task"])
    def agent2(x):
        return x * 3

    # Persists to disk!
    agents = await mesh2.list_agents()
    print(f"Agents: {len(agents)}")

    # Full-text search
    results = await mesh2.discover("task processing agent")
    print(f"Found: {[a.name for a in results]}")

asyncio.run(demo_storage())</code></pre>
            </section>

            <section id="example-trust" class="section">
                <h2>Example: Trust Management</h2>
                <pre><code>import asyncio
import random
from capabilitymesh import Mesh, TrustLevel

async def demo_trust():
    mesh = Mesh()

    @mesh.agent(name="reliable", capabilities=["task"])
    def reliable_agent(x):
        return x * 2  # Always works

    @mesh.agent(name="unstable", capabilities=["task"])
    def unstable_agent(x):
        if random.random() < 0.5:
            raise ValueError("Random failure")
        return x * 2

    # Get agent IDs
    agents = await mesh.list_agents()
    reliable_id = next(a.id for a in agents if a.name == "reliable")
    unstable_id = next(a.id for a in agents if a.name == "unstable")

    # Execute multiple times
    print("Building trust history...")
    for i in range(20):
        try:
            await mesh.execute(reliable_id, i)
        except:
            pass

        try:
            await mesh.execute(unstable_id, i)
        except:
            pass

    # Check trust scores
    print("\n=== Trust Scores ===")
    reliable_score = await mesh.trust.get_score(reliable_id)
    print(f"Reliable agent:")
    print(f"  Level: {reliable_score.level.name}")
    print(f"  Success rate: {reliable_score.success_rate:.1%}")
    print(f"  Executions: {reliable_score.total_executions}")

    unstable_score = await mesh.trust.get_score(unstable_id)
    print(f"\nUnstable agent:")
    print(f"  Level: {unstable_score.level.name}")
    print(f"  Success rate: {unstable_score.success_rate:.1%}")
    print(f"  Executions: {unstable_score.total_executions}")

    # Trust-based discovery
    print("\n=== Trust-Based Discovery ===")
    trusted = await mesh.discover("task", min_trust=TrustLevel.MEDIUM)
    print(f"Trusted agents (MEDIUM+): {[a.name for a in trusted]}")

asyncio.run(demo_trust())</code></pre>
            </section>

            <section id="example-semantic" class="section">
                <h2>Example: Semantic Search</h2>
                <pre><code>import asyncio
from capabilitymesh import Mesh, Capability

async def demo_semantic_search():
    mesh = Mesh()

    # Register agents with rich descriptions
    @mesh.agent(
        name="summarizer",
        capabilities=[
            Capability.create_simple(
                "text-summarization",
                "Extract key points and create concise summaries of long documents",
                tags=["nlp", "summarization", "text-processing", "extraction"]
            )
        ]
    )
    def summarize(text):
        return text[:100]

    @mesh.agent(
        name="translator",
        capabilities=[
            Capability.create_simple(
                "translation",
                "Convert text from one language to another with context awareness",
                tags=["nlp", "translation", "language", "localization"]
            )
        ]
    )
    def translate(text, lang="es"):
        return f"[{lang}] {text}"

    @mesh.agent(
        name="sentiment-analyzer",
        capabilities=[
            Capability.create_simple(
                "sentiment-analysis",
                "Analyze emotional tone and sentiment of text reviews and feedback",
                tags=["nlp", "sentiment", "emotion", "analysis"]
            )
        ]
    )
    def analyze_sentiment(text):
        return {"sentiment": "positive"}

    # Semantic queries
    print("=== Semantic Search Examples ===\n")

    queries = [
        "I need to make this document shorter",
        "Convert text to Spanish",
        "What is the emotional tone of customer reviews?",
        "Process natural language",
    ]

    for query in queries:
        print(f"Query: '{query}'")
        agents = await mesh.discover(query, limit=2)
        print(f"Found: {[a.name for a in agents]}\n")

asyncio.run(demo_semantic_search())</code></pre>
            </section>

            <!-- Troubleshooting -->
            <section id="troubleshooting" class="section">
                <h2>Troubleshooting</h2>

                <h3>Common Issues</h3>

                <h4>1. ModuleNotFoundError</h4>
                <pre><code>ModuleNotFoundError: No module named 'capabilitymesh'</code></pre>
                <p><strong>Solution:</strong></p>
                <pre><code>pip install capabilitymesh</code></pre>

                <h4>2. Redis Connection Error</h4>
                <pre><code>Redis connection failed: Error connecting to localhost:6379</code></pre>
                <p><strong>Solution:</strong></p>
                <pre><code># Start Redis server
redis-server

# Or use Docker
docker run -d -p 6379:6379 redis</code></pre>

                <h4>3. SQLite FTS5 Not Available</h4>
                <pre><code>SQLite FTS5 extension not available</code></pre>
                <p><strong>Solution:</strong></p>
                <pre><code>pip install pysqlite3-binary  # Includes FTS5</code></pre>

                <h4>4. Async Execution Errors</h4>
                <pre><code>RuntimeError: This event loop is already running</code></pre>
                <p><strong>Solution:</strong></p>
                <pre><code># Use asyncio.run() for top-level
asyncio.run(main())

# Or use nest_asyncio in Jupyter
import nest_asyncio
nest_asyncio.apply()</code></pre>

                <h4>5. No Agents Found</h4>
                <pre><code>agents = await mesh.discover("query")
# agents is empty []</code></pre>
                <p><strong>Solution:</strong></p>
                <ul>
                    <li>Check that agents are registered before discovery</li>
                    <li>Lower <code>min_similarity</code> threshold</li>
                    <li>Use more specific capability names</li>
                    <li>Try exact keyword match instead of semantic</li>
                </ul>

                <h4>6. Trust Scores Not Updating</h4>
                <p><strong>Solution:</strong> Trust scores update after each <code>mesh.execute()</code> call. Ensure you're using <code>mesh.execute()</code> and not calling agents directly.</p>
            </section>

            <!-- FAQ -->
            <section id="faq" class="section">
                <h2>FAQ</h2>

                <h3>General Questions</h3>

                <h4>Q: Do I need to use a specific framework?</h4>
                <p>A: No! CapabilityMesh works with ANY framework (CrewAI, AutoGen, LangGraph, A2A) and plain Python functions.</p>

                <h4>Q: Is CapabilityMesh production-ready?</h4>
                <p>A: v1.0.0-alpha.1 is feature-complete with 137 passing tests. It's ready for production use, but expect some refinement based on community feedback.</p>

                <h4>Q: What's the performance impact?</h4>
                <p>A: Minimal. InMemory discovery is < 1ms. SQLite is < 10ms. Redis depends on network latency.</p>

                <h4>Q: Can I use multiple storage backends?</h4>
                <p>A: Not in the same Mesh instance, but you can create multiple Mesh instances with different storage backends.</p>

                <h3>Technical Questions</h3>

                <h4>Q: How does semantic search work without an LLM?</h4>
                <p>A: By default, CapabilityMesh uses TF-IDF based keyword embeddings. For better results, you can plugin OpenAI or sentence-transformers embedders (coming in v1.0-beta).</p>

                <h4>Q: Are trust scores persistent?</h4>
                <p>A: Yes! Trust scores are stored in the storage backend (SQLite or Redis). They persist across restarts.</p>

                <h4>Q: Can I disable trust tracking?</h4>
                <p>A: Not currently, but you can ignore trust scores in discovery by not setting <code>min_trust</code>.</p>

                <h4>Q: How do I migrate between storage backends?</h4>
                <p>A: You'll need to re-register agents with the new storage backend. We're working on a migration tool for v1.1.</p>

                <h3>Framework Integration</h3>

                <h4>Q: Does CapabilityMesh execute framework agents directly?</h4>
                <p>A: It depends. For Python functions, yes. For framework agents, you may need to call the framework's execution API. <code>mesh.get_native()</code> gives you the original agent.</p>

                <h4>Q: Can I mix agents from different frameworks?</h4>
                <p>A: Yes! That's the whole point. Register agents from CrewAI, AutoGen, and LangGraph, then discover and coordinate them together.</p>

                <h4>Q: Is A2A protocol required?</h4>
                <p>A: No. A2A compatibility is built-in, but it's not required. CapabilityMesh works with or without A2A.</p>
            </section>

            <!-- Changelog -->
            <section id="changelog" class="section">
                <h2>Changelog</h2>

                <h3>v1.0.0-alpha.1 (2025-12-09)</h3>
                <p><strong>Initial Alpha Release</strong></p>

                <h4>Core Features</h4>
                <ul>
                    <li>‚úÖ Mesh API for agent registration and discovery</li>
                    <li>‚úÖ Multi-framework support (CrewAI, AutoGen, LangGraph, A2A)</li>
                    <li>‚úÖ Semantic search with keyword embeddings</li>
                    <li>‚úÖ Three storage backends (InMemory, SQLite, Redis)</li>
                    <li>‚úÖ SimpleTrustManager with 5-level trust system</li>
                    <li>‚úÖ Rich capability schemas with versioning</li>
                    <li>‚úÖ A2A protocol compatibility</li>
                </ul>

                <h4>Storage</h4>
                <ul>
                    <li>‚úÖ InMemoryStorage (default, zero-config)</li>
                    <li>‚úÖ SQLiteStorage with FTS5 full-text search</li>
                    <li>‚úÖ RedisStorage for distributed deployments</li>
                </ul>

                <h4>Trust System</h4>
                <ul>
                    <li>‚úÖ Automatic trust scoring based on execution results</li>
                    <li>‚úÖ 5 trust levels (UNTRUSTED ‚Üí VERIFIED)</li>
                    <li>‚úÖ Manual trust level overrides</li>
                    <li>‚úÖ Trust-based discovery filtering</li>
                    <li>‚úÖ Trust statistics and reporting</li>
                </ul>

                <h4>Testing</h4>
                <ul>
                    <li>‚úÖ 137 tests passing (100%)</li>
                    <li>‚úÖ Comprehensive unit tests</li>
                    <li>‚úÖ Integration tests for all features</li>
                    <li>‚úÖ Framework integration tests</li>
                </ul>

                <h4>Documentation</h4>
                <ul>
                    <li>‚úÖ Complete README with examples</li>
                    <li>‚úÖ 6 comprehensive examples</li>
                    <li>‚úÖ EXAMPLES_GUIDE.md</li>
                    <li>‚úÖ DISCOVERY_ARCHITECTURE.md - Deployment patterns guide</li>
                    <li>‚úÖ API documentation (this file)</li>
                    <li>‚úÖ CONTRIBUTING.md</li>
                </ul>

                <h3>Planned Releases</h3>

                <h4>v1.0.0-beta.1 (Coming Soon)</h4>
                <ul>
                    <li>LocalEmbedder (sentence-transformers)</li>
                    <li>OpenAIEmbedder for better semantic search</li>
                    <li>Additional storage backends</li>
                    <li>Performance optimizations</li>
                    <li>Community feedback incorporation</li>
                </ul>

                <h4>v1.0.0 (Stable)</h4>
                <ul>
                    <li>Production hardening</li>
                    <li>Documentation site</li>
                    <li>Tutorial videos</li>
                    <li>Case studies</li>
                </ul>

                <h4>v1.1.0</h4>
                <ul>
                    <li>P2P discovery (mDNS, Gossip, DHT)</li>
                    <li>Advanced negotiation protocols</li>
                    <li>CLI tools</li>
                    <li>Migration utilities</li>
                </ul>
            </section>

            <!-- Footer -->
            <div style="margin-top: 80px; padding-top: 30px; border-top: 2px solid var(--border-color); text-align: center; color: #7f8c8d;">
                <p><strong>CapabilityMesh v1.0.0-alpha.1</strong></p>
                <p>The first and only universal capability mesh for multi-agent systems</p>
                <p style="margin-top: 20px;">
                    <a href="https://github.com/scionoftech/capabilitymesh">GitHub</a> ‚Ä¢
                    <a href="https://pypi.org/project/capabilitymesh">PyPI</a> ‚Ä¢
                    <a href="https://github.com/scionoftech/capabilitymesh/issues">Issues</a> ‚Ä¢
                    <a href="https://github.com/scionoftech/capabilitymesh/discussions">Discussions</a>
                </p>
                <p style="margin-top: 10px; font-size: 14px;">
                    Built with ‚ù§Ô∏è by Sai Kumar Yava
                </p>
            </div>
        </main>
    </div>

    <!-- Back to Top Button -->
    <div class="back-to-top" id="backToTop">‚Üë</div>

    <script>
        // Theme toggle
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        // Load saved theme
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);

        // Active nav link highlighting
        const sections = document.querySelectorAll('.section');
        const navLinks = document.querySelectorAll('.nav-link');

        function highlightNavLink() {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= sectionTop - 100) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        }

        window.addEventListener('scroll', highlightNavLink);

        // Smooth scrolling
        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetSection = document.getElementById(targetId);
                if (targetSection) {
                    targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });

        // Back to top button
        const backToTopButton = document.getElementById('backToTop');

        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                backToTopButton.classList.add('show');
            } else {
                backToTopButton.classList.remove('show');
            }
        });

        backToTopButton.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Simple search functionality
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            if (query.length < 2) {
                navLinks.forEach(link => link.style.display = 'block');
                return;
            }

            navLinks.forEach(link => {
                const text = link.textContent.toLowerCase();
                if (text.includes(query)) {
                    link.style.display = 'block';
                } else {
                    link.style.display = 'none';
                }
            });
        });

        // Initialize
        highlightNavLink();
    </script>
</body>
</html>